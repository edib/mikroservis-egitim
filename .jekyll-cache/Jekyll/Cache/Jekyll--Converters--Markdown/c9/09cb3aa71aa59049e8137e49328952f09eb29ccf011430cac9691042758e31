I"ê<h1 id="bileÅŸenler">BileÅŸenler</h1>

<p>https://kubernetes.io/docs/concepts/overview/components/</p>

<p>Kontrol dÃ¼zlemi, veri dÃ¼zlemi ve yÃ¶netim dÃ¼zlemi, biliÅŸim kaynaklarÄ±ndaki iletiÅŸim mimarisinin Ã¼Ã§ temel bileÅŸenidir. <strong>Kontrol dÃ¼zlemi ve yÃ¶netim dÃ¼zlemi</strong>, tÃ¼m aÄŸÄ±n taÅŸÄ±mak iÃ§in var olduÄŸu trafiÄŸi taÅŸÄ±yan <strong>veri dÃ¼zlemine</strong> hizmet eder. YÃ¶netimsel trafik taÅŸÄ±yan yÃ¶netim dÃ¼zlemi, kontrol dÃ¼zleminin bir alt kÃ¼mesi olarak kabul edilir. Veri dÃ¼zlemi asÄ±l vereceÄŸimiz hizmetin trafiÄŸinin aktÄ±ÄŸÄ± dÃ¼zlemdir.</p>

<h2 id="kontrol-dÃ¼zlemi-bileÅŸenleri">Kontrol DÃ¼zlemi BileÅŸenleri</h2>

<h3 id="kube-apiserver">kube-apiserver</h3>

<p>Kubernetes cluster mekanizmasÄ±nÄ±n ortasÄ±nda yer almaktadÄ±r. Master sunucumuza gelen tÃ¼m REST requestâ€™lerin yÃ¶netilmesi bu araÃ§ Ã¼zerinden gerÃ§ekleÅŸtirilir. TÃ¼m istekler bu servis tarafÄ±ndan kabul edilir ve doÄŸrulanÄ±r, ayrÄ±ca etcd veritabanÄ±na yapÄ±lan tek baÄŸlantÄ± bu ajanla yapÄ±lÄ±r. SonuÃ§ olarak cluster iÃ§erisindeki ana iÅŸlem yeridir diyebiliriz. API hizmeti verir. Gelen istekler doÄŸrular.Â  Kimlik doÄŸrulama, yetkilendirme ve eriÅŸim denetimi yapar.</p>

<ul>
  <li>Static pod olarak kurulur.</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/etc/kubernetes/manifests/kube-apiserver.yaml

</code></pre></div></div>

<h3 id="etcd">etcd</h3>

<p>https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/</p>

<p>Kubernetes Ã¼zerinde gerÃ§ekleÅŸtirilen bÃ¼tÃ¼n konfigÃ¼rasyon ve durumlarÄ±n tutulduÄŸu yÃ¼ksek hÄ±zlÄ± (10000 istek/sn) high-available modâ€™da Ã§alÄ±ÅŸabilen, daÄŸÄ±tÄ±k, tutarlÄ± bir key-value storeâ€™dur.</p>

<ul>
  <li>Raft algoritmasÄ±yla lider seÃ§imi yapar.</li>
  <li>Veriler bellekte durur, istenildiÄŸi zamanlar diske kalÄ±cÄ± olarak yazÄ±labilir.</li>
  <li>HTTP protokolÃ¼ kullanÄ±r.</li>
  <li>TuttuÄŸu deÄŸerler iÃ§in zaman aÅŸÄ±mlarÄ± tanÄ±mlanabilmesine izin verir.</li>
  <li>Kendi ayarlarÄ±na /config ÅŸeklinde HTTP protokolÃ¼yle eriÅŸilebilir.</li>
</ul>

<h4 id="key-vaue-yapÄ±sÄ±">Key-Vaue YapÄ±sÄ±</h4>

<ul>
  <li>key-value Ã§iftleri dÃ¼z bir ikili anahtar dÃ¼zleminde saklanÄ±r.</li>
  <li>Bu anahtar uzayÄ± sÃ¶zlÃ¼k gibi sÄ±ralanÄ±r.</li>
  <li>DeÄŸerler deÄŸiÅŸmez (immutable) olarak tutulur. Varolan bir deÄŸerin deÄŸiÅŸtirilmesi istenirse eski deÄŸeri sÃ¼rÃ¼mleyerek korur ve yeni * deÄŸer oluÅŸturur.Â </li>
  <li>Eski verileri silmek, sÄ±kÄ±ÅŸtÄ±rma (compact) iÅŸlemiyle yapÄ±lÄ±r yoksa verilerin tÃ¼m sÃ¼rÃ¼mleri hep kalÄ±r.</li>
</ul>

<h4 id="dikkat-edilmedi-gerekenler">Dikkat edilmedi Gerekenler</h4>

<ul>
  <li>Etcd tek sayÄ± Ã¼yelerden oluÅŸan bir kÃ¼me olarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.</li>
  <li>Etcdâ€™ye yeterli kaynak verilmesi gerekir. Ã‡ok fazla cpuâ€™ya ihtiyaÃ§ duymaz, canlÄ± sistemlerde 8GB bellek ve ortalama bir disk genel * ihtiyaÃ§larÄ±nÄ± karÅŸÄ±lar.</li>
  <li>KÃ¼menin performansÄ± ve kararlÄ±lÄ±ÄŸÄ±, aÄŸa ve disk performansÄ±na duyarlÄ±dÄ±r. Herhangi bir kaynak aÃ§lÄ±ÄŸÄ±, zaman aÅŸÄ±mÄ±na yol aÃ§arak kÃ¼menin kararsÄ±zlÄ±ÄŸÄ±na neden olabilir. KararsÄ±z bir etcd, hiÃ§bir liderin seÃ§ilmediÄŸini gÃ¶sterir. Bu tÃ¼r koÅŸullar altÄ±nda, bir kÃ¼me mevcut durumunda herhangi bir deÄŸiÅŸiklik yapamaz, bu da yeni podlarÄ±n oluÅŸturulamaz.</li>
  <li>
    <p>Etcd kÃ¼melerini kararlÄ± tutmak, Kubernetes kÃ¼melerinin kararlÄ±lÄ±ÄŸÄ± iÃ§in kritik Ã¶neme sahiptir. Bu nedenle, garantili kaynak gereksinimleri iÃ§in Ã¶zel makinelerde veya yalÄ±tÄ±lmÄ±ÅŸ ortamlarda etcd kÃ¼melerini Ã§alÄ±ÅŸtÄ±rÄ±n.</p>
  </li>
  <li>BaÄŸÄ±msÄ±z docker container olarak kurulur.</li>
</ul>

<h3 id="kube-controller-manager">kube-controller-manager</h3>
<p>Kuberneteste 2 durum vardÄ±r. Declarative olarak kubernetese sÃ¶ylenen ve gerÃ§ekten varolan durum. Temel olarak controller manager, kÃ¼menin durumunu API Server izleme Ã¶zelliÄŸiyle izler ve bildirildiÄŸinde, geÃ§erli durumu istenen duruma doÄŸru hareket ettirmek iÃ§in gerekli deÄŸiÅŸiklikleri yapar.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/etc/kubernetes/manifests/kube-controller-manager.yaml
</code></pre></div></div>

<h3 id="scheduler">scheduler</h3>

<p>Bir podâ€™un hangi node Ã¼zerinde Ã§alÄ±ÅŸacaÄŸÄ±na karar verir , etiketlere gÃ¶re podlarÄ± nodlara daÄŸÄ±tÄ±r, kubeletâ€™i tetikler ve ilgili pod ve iÃ§indeki konteyner Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. KÄ±sacasÄ± yeni bir pod oluÅŸturulmasÄ± isteÄŸine karÅŸÄ± API serverâ€™Ä± izler.Â </p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/etc/kubernetes/manifests/kube-scheduler.yaml
</code></pre></div></div>
<h2 id="dÃ¼ÄŸÃ¼m-bileÅŸenleri">DÃ¼ÄŸÃ¼m BileÅŸenleri</h2>

<h3 id="kubelet">kubelet</h3>

<p>Her bir kubernetes nodeâ€™unda Ã§alÄ±ÅŸan agentâ€™tÄ±r. Ä°lk iÅŸi bulunduÄŸu nodeâ€™u API Serverâ€™a Node resource olarak kayÄ±t ederek Kubernetes tarafÄ±ndan gÃ¶rÃ¼lmesini saÄŸlamaktÄ±r. Bu iÅŸlemden sonra sÃ¼rekli olarak API serverâ€™Ä± dinleyerek bulunduÄŸu nodeâ€™a herhangi bir Pod schedule edip edilmediÄŸini kontrol eder. Schedule eden bir Pod varsa bulunduÄŸu node Ã¼zerinde Podâ€™un iÃ§erisindeki tanÄ±mlanan containerâ€™larÄ± Ã§alÄ±ÅŸtÄ±rÄ±r. Buna ek olarak sÃ¼rekli olarak nodeâ€™da Ã§alÄ±ÅŸan containerâ€™larÄ±n ayakta olup olmadÄ±ÄŸÄ±nÄ± kontrol ederek eriÅŸilebilir olmalarÄ±nÄ± saÄŸlar.</p>

<ul>
  <li>Sistem servisi olarak Ã§alÄ±ÅŸÄ±r.</li>
  <li>```sh
systemctl cat kubelet</li>
</ul>

<p>/etc/kubernetes/kubelet.env</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
## coredns

kube-sytem nste deployment olarak kurulur.

### kube-proxy

Service ve Endpoint objelerinin eriÅŸebilirliÄŸini saÄŸlamak iÃ§in node Ã¼zerindeki network kurallarÄ±nÄ± ayarlar ve connection forwarding iÅŸlemini gerÃ§ekleÅŸtirir. GÃ¶revlerinden biri de Kubernetes Serviceâ€™lere ve Pod'lara virtual IP atamasÄ±dÄ±r.

* daemonset olarak oluÅŸur. 

### CNI 
    https://docs.projectcalico.org/reference/architecture/overview

##### calico

kube-system altÄ±nda calico-kube-controllers adÄ±nda deployment olarak kurulur. calico-node olarak daemonset Ã¼retir. 

```sh
# Ã¶nemli dizinler
/opt/cni/bin/



</code></pre></div></div>

<h3 id="container-runtime">container-runtime</h3>

<ul>
  <li>sistem servisi olarak kurulur.</li>
</ul>

<p>https://www.inovex.de/de/blog/containers-docker-containerd-nabla-kata-firecracker/
https://thenewstack.io/a-security-comparison-of-docker-cri-o-and-containerd/</p>

<h2 id="ek-Ã¶zellikler">Ek Ã–zellikler</h2>

<h1 id="coredns">coredns</h1>
<h1 id="web-ui">web ui</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/ # metrics-server
</code></pre></div></div>

<h1 id="prometheus">prometheus</h1>

<h1 id="kÃ¼me-dÃ¼zeyinde-loglama">KÃ¼me DÃ¼zeyinde Loglama</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://kubernetes.io/docs/concepts/cluster-administration/logging/
</code></pre></div></div>

:ET